# Домашнее задание к занятию 2.2. Массивы многомерные
## Задача 2. Морской бой

### Описание
Вы пишете игру "морской бой" в минимальном варианте, где стреляете только вы.
На входе — двумерный массив 10 на 10, заполненный числами.

Возможные числа: 0 ("пустое поле"), 1 ("есть корабль"), 2 ("корабль застрелен"), 3 ("промах").
При этом "корабли" занимают не более 10 клеток. Расстоянием между кораблями и "палубностью" кораблей мы пренебрегаем.
Пользователь вводит координаты поля, в которое стреляет. 

В зависимости от результата "выстрела" программа выдает ему ответ — "попал"/"не попал".
После попадания во все корабли, либо по истечении 30 ходов, игра считается законченной.
Если за время игры были застрелены все 10 клеток с кораблями, то игра выиграна.

### Функционал программы
1. Создание массива карты 10 на 10 клеток;
2. Автоматическое заполнение полей карты кораблями;
3. Подсчет количества ходов (не должно превышать 30);
4. Проверка все ли корабли подбиты (если да, то победа игрока).

# Пример
```
Игра "Морской бой"
Заполнение кораблей...
Введите координаты для атаки (осталось 30):
1:1
промах
Введите координаты для атаки (осталось 29):
1:2
корабль застрелен
Введите координаты для атаки (осталось 28):
...
Победа! Поздравляем, вы подбили все вражеские корабли!
``` 

### Пример реализации
1. Для решения данной задачи нужно создать двумерный массив 10x10:
``` 
0 - "пустое поле"
1 - "есть корабль"
``` 
Создадим SIZE, для сохранения размерности массива:
```java
// определяем размерность массива
int SIZE = 10;
// Создаем двумерный массив
int warField[][]= new int[SIZE][SIZE];
``` 

Также во время игры ячейки матрицы могут изменяться, получая следующие значения:
``` 
2 - "корабль застрелен"
3 - "промах"
``` 

Для хранения состояния клетки создадим константы и дальше в коде будем использовать их:
```java
int EMPTY = 0;
int SHIP = 1;
int DEAD = 2;
int MISS = 3;
```

2. В условии задачи дано, что максимальное число кораблей 10.
Объявим переменную maxCount для хранения максимального числа кораблей.
```java
int MAX_COUNT = 10;
``` 
Теперь, когда у нас есть поле, разместим на нем корабли.

3. Разместим корабли в случайном порядке на поле (матрица warField):
для этого нужны случайные значения в диапазоне от 0 до 9 для координат ячеек.

Обозначим значения первой размерности shipPlace1, а  второй размерности — shipPlace2.
В таком случае у нас случайные координаты ячеек для кораблей примут следующий вид:
```java
Random random = new Random();
for (int i = 0; i < MAX_COUNT; i++) {
  int shipPlace1 = random.nextInt(SIZE);
  int shipPlace2 = random.nextInt(SIZE);
  
  warField[shipPlace1][shipPlace2] = SHIP;
}
``` 

Так как координаты могут повторяться, внесем некоторые изменения в нашем цикле. Добавим проверку наличия корабля в указанной ячейке, обеспечив при этом повторный круг для данного корабля.

```java
Random random = new Random();
for (int i = 0; i< MAX_COUNT; i++) {
  int shipPlace1 = random.nextInt(SIZE);
  int shipPlace2 = random.nextInt(SIZE);
  
  if (warField[shipPlace1][shipPlace2] == SHIP){
    // повторная генерация положения для данного корабля
    i--;
  }
  
  warField[shipPlace1][shipPlace2] = SHIP;
}
``` 

4. Итак, у нас есть поле с кораблями. Выводим его на экран:

```java 
// выводим массив на экран
// Цикл по первой размерности выводит строки
for (int i = 0; i< SIZE; i++) {
  // Цикл по второй размерности выводит колонки - вывод одной строки
  for (int j = 0; j< SIZE; j++) {
    // Используем оператор print - без перехода на следующую строку
    System.out.print(warField[i][j]);
  }
  // Переход на следующую строку
  System.out.println();
}
``` 
5. Далее необходимо ввести две координаты с клавиатуры с помощью `Scanner.nextInt()`. В зависимости от значения в матрице выводить соответствующее сообщение.

6. После каждого хода выводить обновленную матрицу на экран, а также проверять, не превышено ли максимальное количество шагов и остались ли ещё "не подбитые" корабли в игре.
